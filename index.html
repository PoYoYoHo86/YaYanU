<!-- 中略（styleやcanvas部分は今のままでOK） -->
<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  let paddleX = 350;
  const paddleWidth = 100;
  const paddleHeight = 10;
  const ballRadius = 8;
  let rightPressed = false;
  let leftPressed = false;
  let score = 0;
  let blocksBroken = 0;
  let paddleHue = 0;
  let boostActive = false;
  let boostTimer = 0;

  let balls = [{
    x: 400,
    y: 300,
    dx: 2,
    dy: -2,
    trail: [],
    color: "white"
  }];

  const blockRowCount = 5;
  const blockColumnCount = 10;
  const blockWidth = 70;
  const blockHeight = 20;
  const blockPadding = 10;
  const blockOffsetTop = 60;
  const blockOffsetLeft = 35;

  let blocks = [];
  function initBlocks() {
    for (let c = 0; c < blockColumnCount; c++) {
      blocks[c] = [];
      for (let r = 0; r < blockRowCount; r++) {
        blocks[c][r] = {
          x: 0,
          y: 0,
          status: 1,
          color: `hsl(${Math.random() * 360}, 100%, 50%)`
        };
      }
    }
  }
  initBlocks();

  function drawBlocks() {
    for (let c = 0; c < blockColumnCount; c++) {
      for (let r = 0; r < blockRowCount; r++) {
        if (blocks[c][r].status === 1) {
          const blockX = c * (blockWidth + blockPadding) + blockOffsetLeft;
          const blockY = r * (blockHeight + blockPadding) + blockOffsetTop;
          blocks[c][r].x = blockX;
          blocks[c][r].y = blockY;
          ctx.beginPath();
          ctx.rect(blockX, blockY, blockWidth, blockHeight);
          ctx.fillStyle = blocks[c][r].color;
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  function drawBall(ball) {
    ball.trail.push({ x: ball.x, y: ball.y, alpha: 1 });
    if (ball.trail.length > 10) ball.trail.shift();

    for (let i = 0; i < ball.trail.length; i++) {
      const t = ball.trail[i];
      ctx.beginPath();
      ctx.strokeStyle = `rgba(255, 255, 255, ${t.alpha})`;
      ctx.lineWidth = ballRadius * 2;
      ctx.moveTo(t.x, t.y);
      if (i > 0) ctx.lineTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
      ctx.stroke();
      ctx.closePath();
      t.alpha -= 0.05;
    }

    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    ctx.closePath();
  }

  function drawScore() {
    ctx.font = "20px monospace";
    ctx.fillStyle = "white";
    ctx.textAlign = "left";
    ctx.fillText("SCORE: " + score.toString().padStart(3, "0"), 10, 30);
  }

  function createItem() {} // 省略用のダミー（今は未使用）

  function endGame(win) {
    alert(win ? "You Win!" : "Game Over!");
    document.location.reload();
  }

  function collisionDetection(ball) {
    for (let c = 0; c < blockColumnCount; c++) {
      for (let r = 0; r < blockRowCount; r++) {
        const b = blocks[c][r];
        if (b.status === 1) {
          if (
            ball.x > b.x &&
            ball.x < b.x + blockWidth &&
            ball.y > b.y &&
            ball.y < b.y + blockHeight
          ) {
            ball.dy = -ball.dy;
            b.status = 0;
            score++;
            blocksBroken++;
            if (blocksBroken % 5 === 0) {
              balls.push({
                x: paddleX + paddleWidth / 2,
                y: canvas.height - paddleHeight - 20,
                dx: 2 * (Math.random() > 0.5 ? 1 : -1),
                dy: -2,
                trail: [],
                color: "white"
              });
            }
            if (score === blockRowCount * blockColumnCount) {
              endGame(true);
            }
          }
        }
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBlocks();
    drawPaddle();
    drawScore();

    for (let ball of balls) {
      drawBall(ball);
      collisionDetection(ball);

      // 壁反射
      if (ball.x + ball.dx > canvas.width - ballRadius || ball.x + ball.dx < ballRadius) {
        ball.dx = -ball.dx;
      }
      if (ball.y + ball.dy < ballRadius) {
        ball.dy = -ball.dy;
      } else if (ball.y + ball.dy > canvas.height - ballRadius) {
        if (ball.x > paddleX && ball.x < paddleX + paddleWidth) {
          ball.dy = -ball.dy;
        } else {
          balls = balls.filter(b => b !== ball);
          if (balls.length === 0) {
            endGame(false);
            return;
          }
        }
      }

      ball.x += ball.dx;
      ball.y += ball.dy;
    }

    if (rightPressed && paddleX < canvas.width - paddleWidth) {
      paddleX += boostActive ? 10 : 5;
    } else if (leftPressed && paddleX > 0) {
      paddleX -= boostActive ? 10 : 5;
    }

    if (boostActive) {
      boostTimer--;
      if (boostTimer <= 0) {
        boostActive = false;
        document.getElementById("boostIcon").style.opacity = 0.3;
      }
    }

    requestAnimationFrame(draw);
  }

  document.addEventListener("keydown", e => {
    if (e.key === "ArrowRight") rightPressed = true;
    if (e.key === "ArrowLeft") leftPressed = true;
    if (e.key === "z" || e.key === "Z") {
      boostActive = true;
      boostTimer = 60;
      document.getElementById("boostIcon").style.opacity = 1;
    }
  });
  document.addEventListener("keyup", e => {
    if (e.key === "ArrowRight") rightPressed = false;
    if (e.key === "ArrowLeft") leftPressed = false;
  });

  draw();
</script>
